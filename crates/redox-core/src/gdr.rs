use std::{
	fs::File,
	io::{self, Write},
};

use anyhow::Result;

use crate::state::Action;

#[derive(Clone, Default, Debug)]
pub struct Bot {
	pub name: String,
	pub version: i32,
}

#[derive(Clone, Default, Debug)]
pub struct Level {
	pub id: u32,
	pub name: String,
}

#[derive(Clone, Debug)]
pub struct Input {
	pub frame: u64,
	pub button: u8, // 1 = Jump, 2 = Left, 3 = Right (Platformer)
	pub player2: bool,
	pub down: bool,
	// Optional extension data for this specific input
	pub extension: Option<Vec<u8>>,
}

#[derive(Clone, Debug)]
pub struct Replay {
	pub version: i32, // typically 2
	pub input_tag: String,
	pub author: String,
	pub description: String,
	pub duration: f32, // C++ uses float
	pub game_version: i32,
	pub framerate: f64, // C++ uses double
	pub seed: i32,
	pub coins: i32,
	pub ldm: bool,
	pub platformer: bool,
	pub bot_info: Bot,
	pub level_info: Level,
	pub extension: Option<Vec<u8>>, // replay-level extension bytes
	pub deaths: Vec<u64>,
	pub inputs: Vec<Input>,
}

impl Default for Replay {
	fn default() -> Self {
		Self {
			version: 2,
			input_tag: String::new(),
			author: "Redox".to_string(),
			description: "Generated by Redox Pathfinding Solver".to_string(),
			duration: 0.0,
			game_version: 22074, // 2.2074
			framerate: 240.0,
			seed: 0,
			coins: 0,
			ldm: false,
			platformer: false,
			bot_info: Bot {
				name: "Redox".to_string(),
				version: 1,
			},
			level_info: Level {
				id: 0,
				name: "Unknown".to_string(),
			},
			extension: None,
			deaths: Vec::new(),
			inputs: Vec::new(),
		}
	}
}

impl Replay {
	pub fn serialize(&self) -> io::Result<Vec<u8>> {
		let mut buf = Vec::new();

		// Header: "GDR" + version
		buf.extend_from_slice(b"GDR");
		// Version 2
		buf.push(2);

		Ok(buf)
	}
}

impl Replay {
	pub fn serialize_full(&self) -> io::Result<Vec<u8>> {
		let mut buf = Vec::new();

		// Header: "GDR" + version
		buf.extend_from_slice(b"GDR");
		write_varint(&mut buf, self.version as u64);
		write_string(&mut buf, &self.input_tag);

		// Metadata
		write_string(&mut buf, &self.author);
		write_string(&mut buf, &self.description);

		// Duration (float, big-endian)
		write_f32_be(&mut buf, self.duration);

		write_varint(&mut buf, self.game_version as u64);
		// Framerate (double, big-endian)
		write_f64_be(&mut buf, self.framerate);

		write_varint(&mut buf, self.seed as u64);
		write_varint(&mut buf, self.coins as u64);
		buf.push(if self.ldm { 1 } else { 0 });
		buf.push(if self.platformer { 1 } else { 0 });

		write_string(&mut buf, &self.bot_info.name);
		write_varint(&mut buf, self.bot_info.version as u64);

		write_varint(&mut buf, self.level_info.id as u64);
		write_string(&mut buf, &self.level_info.name);

		// Replay extension block
		if let Some(ext) = &self.extension {
			write_varint(&mut buf, ext.len() as u64);
			buf.extend_from_slice(ext);
		} else {
			write_varint(&mut buf, 0);
		}

		// Deaths
		write_varint(&mut buf, self.deaths.len() as u64);
		let mut p = 0u64;
		for &d in &self.deaths {
			// Delta encoded
			let delta = d.saturating_sub(p);
			write_varint(&mut buf, delta);
			p = d;
		}

		// Inputs
		write_varint(&mut buf, self.inputs.len() as u64);

		// Count P1 inputs for the split
		let p1_count = self.inputs.iter().filter(|i| !i.player2).count();
		write_varint(&mut buf, p1_count as u64);

		// 1. Write P1 inputs
		let mut prev = 0u64;
		for i in self.inputs.iter().filter(|i| !i.player2) {
			let delta = i.frame.saturating_sub(prev);

			let packed = if self.platformer {
				pack_platformer(delta, i.button, i.down)
			} else {
				pack_non_platformer(delta, i.down)
			};
			write_varint(&mut buf, packed);

			// Extension for input (only if input_tag is not empty)
			if !self.input_tag.is_empty() {
				if let Some(ext) = &i.extension {
					write_varint(&mut buf, ext.len() as u64);
					buf.extend_from_slice(ext);
				} else {
					write_varint(&mut buf, 0);
				}
			}

			prev = i.frame;
		}

		// 2. Write P2 inputs (reset prev)
		let mut prev = 0u64;
		for i in self.inputs.iter().filter(|i| i.player2) {
			let delta = i.frame.saturating_sub(prev);

			let packed = if self.platformer {
				pack_platformer(delta, i.button, i.down)
			} else {
				pack_non_platformer(delta, i.down)
			};
			write_varint(&mut buf, packed);

			// Extension for input
			if !self.input_tag.is_empty() {
				if let Some(ext) = &i.extension {
					write_varint(&mut buf, ext.len() as u64);
					buf.extend_from_slice(ext);
				} else {
					write_varint(&mut buf, 0);
				}
			}

			prev = i.frame;
		}

		Ok(buf)
	}
}

fn write_varint(buf: &mut Vec<u8>, mut v: u64) {
	if v == 0 {
		buf.push(0);
		return;
	}
	while v > 0 {
		let mut byte = (v & 0x7F) as u8;
		v >>= 7;
		if v != 0 {
			byte |= 0x80;
			buf.push(byte);
		} else {
			buf.push(byte);
			break;
		}
	}
}

fn write_string(buf: &mut Vec<u8>, s: &str) {
	write_varint(buf, s.len() as u64);
	buf.extend_from_slice(s.as_bytes());
}

fn write_f32_be(buf: &mut Vec<u8>, v: f32) {
	buf.extend_from_slice(&v.to_be_bytes());
}

fn write_f64_be(buf: &mut Vec<u8>, v: f64) {
	buf.extend_from_slice(&v.to_be_bytes());
}

fn pack_platformer(delta: u64, button: u8, down: bool) -> u64 {
	(delta << 3) | ((button as u64) << 1) | (down as u64)
}

fn pack_non_platformer(delta: u64, down: bool) -> u64 {
	(delta << 1) | (down as u64)
}

/// Saves the given path as a .gdr replay file.
pub fn save_gdr(path: &[(Action, f32)], out_path: &std::path::Path, fps: usize) -> Result<()> {
	let mut inputs = Vec::new();
	let framerate = fps as f64;
	let mut current_time = 0.0;

	for (action, duration) in path {
		match action {
			Action::Press => {
				let frame = (current_time * framerate).round() as u64;
				inputs.push(Input {
					frame,
					button: 1, // Jump/Hold button
					player2: false,
					down: true,
					extension: None,
				});
			}
			Action::Release => {
				let frame = (current_time * framerate).round() as u64;
				inputs.push(Input {
					frame,
					button: 1,
					player2: false,
					down: false,
					extension: None,
				});
			}
			Action::None => {}
		}

		current_time += *duration as f64;
	}

	let replay = Replay {
		framerate,
		duration: current_time as f32,
		inputs,
		platformer: false,
		..Default::default()
	};

	let data = replay.serialize_full()?;
	let mut f = File::create(out_path)?;
	f.write_all(&data)?;

	Ok(())
}
