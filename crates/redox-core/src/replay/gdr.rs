use std::{
	fs::File,
	io::{self, Write},
};

use anyhow::Result;

use crate::state::Action;

#[derive(Clone, Default, Debug)]
pub struct Bot {
	pub name: String,
	pub version: i32,
}

#[derive(Clone, Default, Debug)]
pub struct Level {
	pub id: u32,
	pub name: String,
}

#[derive(Clone, Debug)]
pub struct Input {
	pub frame: u64,
	pub button: u8, // 1 = Jump, 2 = Left, 3 = Right (Platformer)
	pub player2: bool,
	pub down: bool,
	// Optional extension data for this specific input
	pub extension: Option<Vec<u8>>,
}

#[derive(Clone, Debug)]
pub struct Replay {
	pub version: i32, // typically 2
	pub input_tag: String,
	pub author: String,
	pub description: String,
	pub duration: f32, // C++ uses float
	pub game_version: i32,
	pub framerate: f64, // C++ uses double
	pub seed: i32,
	pub coins: i32,
	pub ldm: bool,
	pub platformer: bool,
	pub bot_info: Bot,
	pub level_info: Level,
	pub extension: Option<Vec<u8>>, // replay-level extension bytes
	pub deaths: Vec<u64>,
	pub inputs: Vec<Input>,
}

impl Default for Replay {
	fn default() -> Self {
		Self {
			version: 2,
			input_tag: String::new(),
			author: "Redox".to_string(),
			description: "Generated by Redox Pathfinding Solver".to_string(),
			duration: 0.0,
			game_version: 22074, // 2.2074
			framerate: 240.0,
			seed: 0,
			coins: 0,
			ldm: false,
			platformer: false,
			bot_info: Bot {
				name: "Redox".to_string(),
				version: 1,
			},
			level_info: Level {
				id: 0,
				name: "Unknown".to_string(),
			},
			extension: None,
			deaths: Vec::new(),
			inputs: Vec::new(),
		}
	}
}

impl Replay {
	pub fn serialize(&self) -> io::Result<Vec<u8>> {
		let mut buf = Vec::new();

		// Header: "GDR" + version
		buf.extend_from_slice(b"GDR");
		// Version 2
		buf.push(2);

		Ok(buf)
	}

	pub fn serialize_full(&self) -> io::Result<Vec<u8>> {
		let mut buf = Vec::new();

		// Header: "GDR" + version
		buf.extend_from_slice(b"GDR");
		write_varint(&mut buf, self.version as u64);

		// Author, description
		write_string(&mut buf, &self.author);
		write_string(&mut buf, &self.description);

		// Duration (f32)
		buf.extend_from_slice(&self.duration.to_be_bytes());
		// Game version (varint)
		write_varint(&mut buf, self.game_version as u64);
		// Framerate (f64)
		buf.extend_from_slice(&self.framerate.to_be_bytes());
		// Seed (varint)
		write_varint(&mut buf, self.seed as u64);
		// Coins (varint)
		write_varint(&mut buf, self.coins as u64);
		// Flags: ldm (bit 0), platformer (bit 1)
		let mut flags: u8 = 0;
		if self.ldm {
			flags |= 1 << 0;
		}
		if self.platformer {
			flags |= 1 << 1;
		}
		buf.push(flags);

		// Bot info
		write_string(&mut buf, &self.bot_info.name);
		write_varint(&mut buf, self.bot_info.version as u64);

		// Level info
		write_varint(&mut buf, self.level_info.id as u64);
		write_string(&mut buf, &self.level_info.name);

		// Extension data
		if let Some(ext) = &self.extension {
			write_varint(&mut buf, ext.len() as u64);
			buf.extend_from_slice(ext);
		} else {
			write_varint(&mut buf, 0);
		}

		// Deaths
		write_varint(&mut buf, self.deaths.len() as u64);
		for d in &self.deaths {
			write_varint(&mut buf, *d);
		}

		// Inputs
		write_varint(&mut buf, self.inputs.len() as u64);
		let mut last_frame = 0;
		for input in &self.inputs {
			// GDR uses delta frames
			let delta = input.frame - last_frame;
			write_varint(&mut buf, delta);
			last_frame = input.frame;

			// Input bitmask: jump(0), left(1), right(2), player2(3), down(4)
			let mut bits: u8 = 0;
			match input.button {
				1 => bits |= 1 << 0,
				2 => bits |= 1 << 1,
				3 => bits |= 1 << 2,
				_ => {}
			}
			if input.player2 {
				bits |= 1 << 3;
			}
			if input.down {
				bits |= 1 << 4;
			}
			buf.push(bits);

			// Input extension
			if let Some(ext) = &input.extension {
				write_varint(&mut buf, ext.len() as u64);
				buf.extend_from_slice(ext);
			} else {
				write_varint(&mut buf, 0);
			}
		}

		Ok(buf)
	}
}

pub fn save_gdr(path: &Vec<(Action, f32)>, out_path: &str, fps: f32) -> Result<()> {
	let mut replay = Replay {
		framerate: fps as f64,
		..Default::default()
	};

	let mut current_frame: u64 = 0;
	let mut _is_pressing = false;

	// Initial state
	replay.inputs.push(Input {
		frame: 0,
		button: 0,
		player2: false,
		down: false,
		extension: None,
	});

	for (action, duration) in path {
		let frames = (duration * fps).round() as u64;

		match action {
			Action::Press => {
				_is_pressing = true;
				replay.inputs.push(Input {
					frame: current_frame,
					button: 1, // Jump
					player2: false,
					down: false,
					extension: None,
				});
			}
			Action::Release => {
				_is_pressing = false;
				replay.inputs.push(Input {
					frame: current_frame,
					button: 0,
					player2: false,
					down: false,
					extension: None,
				});
			}
			Action::None => {}
		}

		current_frame += frames;
	}

	let data = replay.serialize_full()?;
	let mut file = File::create(out_path)?;
	file.write_all(&data)?;

	Ok(())
}

fn write_varint(buf: &mut Vec<u8>, mut val: u64) {
	loop {
		let mut byte = (val & 0x7F) as u8;
		val >>= 7;
		if val != 0 {
			byte |= 0x80;
		}
		buf.push(byte);
		if val == 0 {
			break;
		}
	}
}

fn write_string(buf: &mut Vec<u8>, s: &str) {
	write_varint(buf, s.len() as u64);
	buf.extend_from_slice(s.as_bytes());
}
